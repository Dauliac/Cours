---
header: 'Cours des syst√®mes'
footer: 'Julien Dauliac -- ynov.casualty925@passfwd.com'
---

<!-- headingDivider: 3 -->
<!-- paginate: true -->
<!-- colorPreset: sunset -->

# Cours des syst√®mes

[TOC]

# Introduction

## Objectifs
- Comprendre le processus de d√©marrage d'un syst√®me, de l'initialisation du BIOS √† l'ex√©cution du noyau.
- Avoir des bases sur les architectures des syst√®me d'exploitation.
- Explorer les diff√©rentes formes d'isolation, notamment les machines virtuelles, les conteneurs et les lambdas, et comprendre leurs avantages et inconv√©nients.


## C‚Äôest quoi un OS ?

[Wooclap](https://app.wooclap.com/events/FKFKTZ/questions/64fe433fa84d0f1d6fea38b2)

[Question 1](https://app.wooclap.com/events/FKFKTZ/questions/64fe435da84d0f1d6fea39e5)


### Quelle est la proposition d‚Äôun OS:

- J‚Äôen ait besoin:
    - non mais si c‚Äôest un ordinateur personnel (PC), c‚Äôest mieux
- Pourquoi faire:
    - Abstraire le mat√©riel

## Un syst√®me simple pour commencer

- BIOS
- D√©marrage du kernel par le bios
- Cr√©ation du processus 0 par le kernel
- IDLE = processus qui ne fait rien:
    
    ```c
    while(true) {}
    ```
---

![](assets/system-2.svg)

# BIOS

- **Fun fact:** üçé Le bruit de d√©marrage des Mac vient d‚Äôun sample ill√©gal l‚Äôalbum sergent pepper des beatles.

## BIOS de barbu


![width:200px](assets/Untitled.png)
![width:200px](assets/Untitled%201.png)

## BIOS de corpo kid


![width:200px](assets/Untitled%202.png)
![width:200px](assets/Untitled%203.png)

## BIOS de beauf

![width:200px](assets/Untitled%204.png)
![width:200px](assets/Untitled%205.png)

## Qu‚Äôest ce qu‚Äôun `BIOS`

- La premi√®re instruction ex√©cut√©e par le processeur
- D√©couverte et initialisation du mat√©riel
    - Processeurs, m√©moire, contr√¥leurs d'E/S, p√©riph√©riques, etc.
- Configuration mat√©rielle
- D√©marrage du syst√®me d'exploitation
- Nom ancien

### Un abus de language

- *Extensible Firmware Interface ‚Üí INTEL*
- **Unified Extensible Firmware Interface ‚Üí** [AMD](https://fr.wikipedia.org/wiki/Advanced_Micro_Devices), [American Megatrends](https://fr.wikipedia.org/wiki/American_Megatrends), [Apple](https://fr.wikipedia.org/wiki/Apple), [ARM](https://fr.wikipedia.org/wiki/ARM_(entreprise)), [Dell](https://fr.wikipedia.org/wiki/Dell), [HP](https://fr.wikipedia.org/wiki/Hewlett-Packard), [Intel](https://fr.wikipedia.org/wiki/Intel), [IBM](https://fr.wikipedia.org/wiki/International_Business_Machines_Corporation), Insyde Software, [Microsoft](https://fr.wikipedia.org/wiki/Microsoft) et [Phoenix Technologies](https://fr.wikipedia.org/wiki/Phoenix_Technologies)

### Architecture de l‚ÄôUEFI

[UEFI](https://fr.wikipedia.org/wiki/UEFI)

---

- SEC (*Security*) pour l'ex√©cution des processus d'authentification et de contr√¥le d'int√©grit√© (SecureBoot, mot de passe, token USB)

---

- PEI (*Pre EFI Initialization*) pour l'initialisation de la carte m√®re et du *chipset*. Passage du processeur en mode prot√©g√©

---

- DXE (*Driver Execution Environment*) pour l'enregistrement de tous les pilotes. Le routage par un dispatcher des demandes issues des applications EFI comme un chargeur de
d√©marrage

---

- BDS (*Boot Dev Select*) pour un gestionnaire de d√©marrage comme [grub](https://fr.wikipedia.org/wiki/GRand_Unified_Bootloader)

---

- TSL (*Transient System Load*) pour la phase transitoire o√π le syst√®me d'exploitation est charg√©. Les
services EFI seront clos via la fonction ExitBootServices(), pour passer la main au syst√®me d'exploitation

---

- RT (*RunTime*) quand le
syst√®me d'exploitation a pris la main. Le seul moyen d'interagir avec le firmware est alors de passer par les variables EFI stock√©es dans la
NVRAM.


---

![](assets/system-mermaid-bios.svg)


## S√©curit√©

> Le BIOS n‚Äôest pas notre royaume, mais faisons attentions aux fondations.
> 
- D√©finir un mot de passe UEFI
- Activez le secure boot:
    - signe le bootloader, le kernel, et v√©rifie les signatures au d√©marrage.

## Un bios open source üéä

**Open Firmware**

[Firmware Switching (Proprietary Firmware or System76 Open Firmware)](https://support.system76.com/articles/transition-firmware/)

# Kernel

- Code mort
- charg√© au d√©marrage
- qui vient isoler les programme de la machine
- Interface avec le user space: `SYSCALL`

## R√©sum√© des composants du Noyau

| √âl√©ments | Description | Temps de l‚Äô√©tudier |
| --- | --- | --- |
| Scheduler | Le noyau d√©cide quels processus doivent s'ex√©cuter et pendant combien de temps, en utilisant des politiques d'ordonnancement. | ‚úÖ |
| Gestion des Processus | Le noyau g√®re les processus et les threads, d√©cidant de leur allocation de temps CPU et de leurs priorit√©s. | ‚úÖ |
| appel syst√®me | Gestion des demandes au syst√®me d‚Äôexploitation | ‚úÖ |
| Gestion des Entr√©es/Sorties | Le noyau facilite les op√©rations d'entr√©e/sortie entre les p√©riph√©riques mat√©riels et les processus logiciels, en utilisant des m√©canismes tels que les pilotes de p√©riph√©riques. | ‚ùå |
| Drivers | Gestion des  externes. | ‚ùå |
| Communication Inter-Processus | Le noyau fournit des m√©canismes pour la communication entre les processus, tels que les signaux, les tubes et les s√©maphores. | ‚ùå |
| Partage de la RAM entre processus | Le syst√®me utilise un syst√®me de m√©moire virtuelle et de page pour isoler et partager la RAM entre les processus. | ‚ùå |

## Scheduler
*Un quoi ?*

### Comment fait-on pour lancer plusieurs processus ?

![](assets/system-2.svg)


### Ordonnanceur et temporisateur

![](assets/system-3.svg)

---

- Ordonnanceur: algorithme bas√© qui utilise un circuit temporisateur pour partag√© l‚Äôacc√®s aux c≈ìurs.
- Le kernel interrompt le processus.
- Le temps de laisser la parole √† tout les processus on appelle cela une **epoch**.
- Pour fonctionner l‚Äôordonnanceur utilise des **interruptions syst√®me**

### Algorithmes d‚Äôordonnancements

- Round Robin chacun son tour
- Par priorit√©
- Multi level-feedback round robin Queues

---

Comme dans la vie, on peut cr√©er des in√©galit√©s

```bash
# renice - alter priority of running processes
renice
```

---

**example:**

Sur des syst√®mes critiques comme les fus√©es üöÄ on peut d√©finit la priorit√© de chaque processus.
C‚Äôest d‚Äôautant plus simple quand on conna√Æt la liste de tout les processus √† l‚Äôavance.

## Les syscalls

![](assets/system-1.svg)

---

- Protocole de communication avec le kernel
- Une liste de num√©ros
- Dans les sources du kernel:
    
    ```c
    SYSCALL_DEFINE3(ioctl, unsigned int, fd, unsigned int, cmd, unsigned long, arg)
    {
    /* do freaky ioctl stuff */
    }
    ```

---    

| System Call | rax | rdi | rsi | rdx | r10 | r8 | r9 |
| --- | --- | --- | --- | --- | --- | --- | --- |
| sys_chroot | 161 | const char* filename |  |  |  |  |  |
| sys_chmod | 90 | const char* filename | uid_t user | gid_t group |  |  |  |
| sys_mkdir | 83 | const char* pathname | int mode |  |  |  |  |

[documentation des syscalls](https://github.com/torvalds/linux/blob/28f20a19294da7df158dfca259d0e2b5866baaf9/arch/x86/entry/syscalls/syscall_64.tbl)

# Processus

## Premier processus

Quiz: Quel est le premier processus qui est g√©n√©ralement lanc√© sur linux ?

---

```bash
ps -aux | grep init
root           1  0.0  0.0 166896 11700 ?        Ss   10:19   0:01 /sbin/init splash
dauliac    44107  0.0  0.0  19016  2560 pts/0    S+   19:53   0:00 grep --color=auto init

~
‚ûú ls -la /sbin/init
lrwxrwxrwx 20 root 10 ao√ªt  18:37 /sbin/init -> /lib/systemd/systemd
```

## Histoire de l‚Äôarchitecture de la RAM

### 2 mod√®les

- Architecture Harvard
    - D'abord mis en ≈ìuvre dans le Mark I (1944).
    - Gardez les programmes et les donn√©es s√©par√©s.
    - Permet de r√©cup√©rer des donn√©es et des instructions en m√™me temps.
    - Simple √† manipuler pour les programmeurs mais moins puissant pour les ordinateurs.
- Architecture Princeton
    - D'abord mis en ≈ìuvre dans l'ENIAC (1946).
    - Permet de coder en auto-modifiant et l'entrelacement de programme et de donn√©es.
    - Difficile √† manipuler pour les programmeurs mais plus puissant pour les ordinateurs.

### Et maintenant

Quiz: Quelle architecture utilise-on ?

---

Les 2.

---

- Les programmeurs codent en architecture Harvard.
- Les machines ex√©cutent le code en architecture Princeton.
- Les compilateurs traduisent le code de l'architecture Harvard √† l'architecture Princeton.

---

- Mais, quelques pertes se produisent dans la traduction... et certains bugs peuvent permettre √† des utilisateurs malveillants d'acc√©der √† des fonctionnalit√©s non autoris√©es gr√¢ce √† des comportements inattendus.
La plupart des probl√®mes de s√©curit√© dans la s√©curit√© des logiciels viennent d'une mauvaise compr√©hension du couplage de ces deux architectures.
- L'exploitation consiste essentiellement √† utiliser cette "machine" en dehors de ses sp√©cifications.

## Le layout de la ram

[Wooclap](https://app.wooclap.com/events/FKFKTZ/questions/64fe435da84d0f1d6fea39e5)

---

![](assets/system-4.svg)

---

| Position | Contenu |
| --- | --- |
| Stack | Utilis√© pour stocker les variables locales, les adresses de retour des fonctions et les donn√©es temporaires. |
| Heap | Utilis√© pour la gestion dynamique de la m√©moire, telles que l'allocation et la lib√©ration de m√©moire. |
| Bss | Contient les donn√©es non initialis√©es ou initialis√©es √† z√©ro, telles que les variables statiques globales. |
| Data | Stocke les donn√©es initialis√©es, telles que les variables statiques globales avec une valeur sp√©cifi√©e. |
| R/O Data | constantes, cha√Ænes de caract√®re litt√©rales  |
| Text | Contient le code ex√©cutable du programme. |

## S√©curit√© de la ram

---

- **Address space layout randomization:**
    
    s‚Äôagit en g√©n√©ral de la position du [tas](https://fr.wikipedia.org/wiki/Tas_(informatique)), de la [pile](https://fr.wikipedia.org/wiki/Pile_(informatique)) et des [biblioth√®ques](https://fr.wikipedia.org/wiki/Biblioth%C3%A8que_logicielle). Ce proc√©d√© permet de limiter les effets des attaques de type [d√©passement de tampon](https://fr.wikipedia.org/wiki/D%C3%A9passement_de_tampon) par exemple.
    
    - L‚Äôimpl√©mentation sous Linux est support√©e dans le noyau depuis la version¬†2.6.20 (June 1, 2005)
    
    [Address space layout randomization](https://fr.wikipedia.org/wiki/Address_space_layout_randomization)
---

- **Non-executable stack**

---

- **Control-related data in read-only regions**

---

- **Canary:**
    - Pr√©vient du d√©bordement de tampon bas√© sur la pile
    - V√©rifi√© avant l'instruction assembleur `ret`
    - Id√©alement al√©atoire (et par thread)

## Processus states

![](assets/system-5.svg)

## Pagination virtuelle

On a pas le temps d√©sol√© üòï

Mais en gros la m√©moire dans le kernel est g√©r√©e avec un syst√®me de page qui permet d‚Äôisoler les processus et de distribuer la m√©moire de mani√®re extr√™mement performante (cf partie processus).

# Les nouvelles isolations üîí

Le kernel est une premi√®re forme d‚Äôisolation

## Les machines virtuelles

![](assets/system-10.svg)

---

| Outil | Description | Example |
| --- | --- | --- |
| L‚Äô√©mulateur | Simule le mat√©riel | QEMU |
| Hyperviseur | Outil de contr√¥le des syst√®mes d‚Äôexploitation | KVM |
- Dans certains cas, KVM n‚Äôutilise pas d‚Äô√©mulation pour les processeurs, mais utilise directement le kernel haute pour y acc√©der.

## Les containers üêã

![](assets/system-8.svg)

---

| √âl√©ments | Description  |
| --- | --- |
| Dockefile | Fichier texte d√©clarant comment construire une image |
| Image | Archive contenant le filesystem et les m√©ta donn√©es permettant d‚Äôex√©cuter le container. |
| Registry | Depo permettant de versionner, partager, r√©cup√©rer et t√©l√©charger les images. |
| Runtime | Permet d‚Äôex√©cuter les containers (containerd) |
| Frontend | Client permettant d‚Äôinteragir avec ces √©l√©ments: docker, podman, kaniko. |

### Dockerfile
```Dockerfile
FROM alpine

COPY \
    package.json package-lock.json \
    /var/lib/app/
RUN \
    npm install \
    npm run build
COPY ./src /var/lib/app

CMD npm run prod
```

---

**Conseils:**
- Utiliser [hadolint](https://github.com/hadolint/hadolint)
- Utiliser [trivy](https://github.com/aquasecurity/trivy)
- Faire des images avec un seul processus

---

| Avantages des `Dockerfiles`          | Inconv√©nients des `Dockerfiles`                  |
|-----------------------------------|-----------------------------------------------|
| 1. **Reproductibilit√©** : Les Dockerfiles permettent de d√©finir de mani√®re pr√©cise l'environnement d'une application, garantissant ainsi que l'application se comportera de la m√™me mani√®re partout o√π le conteneur Docker est ex√©cut√©. | 1. **Nature Imp√©rative** : Les Dockerfiles sont imp√©ratifs, ce qui signifie que vous sp√©cifiez les √©tapes de construction plut√¥t que de d√©crire l'√©tat souhait√©. Cela peut rendre difficile la compr√©hension de l'environnement cible. |
| 2. **Isolation** : Les Dockerfiles permettent d'isoler une application et ses d√©pendances, ce qui √©vite les conflits entre les diff√©rentes applications s'ex√©cutant sur la m√™me machine h√¥te. | 2. **Maintenance** : Les Dockerfiles n√©cessitent une maintenance continue pour rester √† jour avec les nouvelles versions des d√©pendances, ce qui peut devenir fastidieux. |
| 3. **Gestion des Versions** : Les Dockerfiles peuvent √™tre versionn√©s et g√©r√©s avec des syst√®mes de contr√¥le de version, ce qui facilite la gestion des modifications de configuration au fil du temps. | 3. **Taille du Conteneur** : Les Dockerfiles peuvent g√©n√©rer des images de conteneur volumineuses, car chaque instruction ajoute des couches au syst√®me de fichiers de l'image. Cela peut augmenter les temps de transfert et d'ex√©cution. |
| 4. **Reconstruction Rapide** : En utilisant un Dockerfile, vous pouvez rapidement reconstruire une image de conteneur en cas de besoin, ce qui facilite le d√©ploiement continu. | 4. **Complexit√© Potentielle** : Les Dockerfiles peuvent devenir complexes, en particulier pour les applications multi-√©tapes ou avec de nombreuses d√©pendances. La gestion de cette complexit√© peut √™tre difficile. |
| 5. **Automatisation** : Les Dockerfiles peuvent √™tre utilis√©s dans des pipelines CI/CD pour automatiser la construction et le d√©ploiement de conteneurs, ce qui acc√©l√®re les processus de d√©veloppement et de d√©ploiement. | 5. **Difficile √† D√©boguer** : Les erreurs dans un Dockerfile peuvent √™tre difficiles √† d√©boguer, car il peut √™tre compliqu√© de d√©terminer o√π l'erreur s'est produite. |

---

### Les containers et les syscalls

> Les containers font reposer leurs fonctionnement sur une suite de `syscall`.
> 

| Appel Syst√®me | Description |
| --- | --- |
| Clone (sys_clone) | Cr√©e des processus l√©gers et partage certaines parties de l'espace d'adressage avec le parent. |
| Namespace (sys_unshare, sys_setns, etc.) | Isolation des ressources syst√®me telles que les processus, les r√©seaux, les points de montage, etc. |
| Cgroups (Control Groups) | Gestion des limites et contraintes sur les ressources syst√®me (CPU, m√©moire, r√©seau, etc.). |
| Chroot (sys_chroot) | Modification de la racine du syst√®me de fichiers pour cr√©er un environnement de fichiers isol√©. |
| Seccomp (Secure Computing Mode) | Restreint les appels syst√®me disponibles pour un processus, renfor√ßant ainsi la s√©curit√©. |
| Capacit√©s (capabilities) | Accorde des droits sp√©cifiques aux processus pour effectuer certaines actions normalement r√©serv√©es √† l'utilisateur root. |
| Sysfs, procfs, etc. | Utilisation de syst√®mes de fichiers virtuels pour obtenir des informations sur l'√©tat du syst√®me et ajuster les param√®tres du noyau. |
| Socketpair (sys_socketpair) | Cr√©e des paires de sockets pour la communication inter-processus (IPC) entre les processus dans le m√™me conteneur. |
| Privil√®ges d'espace utilisateur | Cr√©e des comptes d'utilisateurs isol√©s dans l'espace utilisateur, renfor√ßant ainsi l'isolation des utilisateurs entre les conteneurs. |
| Appels Syst√®mes R√©seau (sys_socket, etc.) | Utilis√©s pour √©tablir des connexions r√©seau, souvent avec des restrictions sp√©cifiques au conteneur pour garantir l'isolation. |

[Digging into Linux namespaces - part 1](https://blog.quarkslab.com/digging-into-linux-namespaces-part-1.html)

### Les lambdas üìè

- Se d√©barrasser d‚Äôun maximum de composants: Il ne reste que la RAM, le r√©seau, les c≈ìurs
    - Pas de gestion des fichiers
    - Plus d‚Äôacc√®s a l‚Äôhyperviseur

---

![](assets/system-9.svg)

---

| √âl√©ments | Description  |
| --- | --- |
| Code | Code √† ex√©cuter en tant que lambda |
| Scheduler | Backend permettant de distribuer le calculs des lambdas |
| Biblioth√®que | Packet permettant de rendre compatible le code avec les apis des lamdbas. |

---

Les lambdas c‚Äôest juste

- des processus
- Ex√©cut√© dans des containers, ou des vms, ou une machine üò±

---

| Avantages üåà | Inconvenants üò¢ |
| --- | --- |
| Peu de couplage | Peut co√ªter cher |
| Isolation de tout les processus | Difficile √† mettre en place avec des logiciels libre |
| Permet d‚Äôarchitecturer des applications √©volutives | Peut facilement vendor lock. |
| Uniquement d√©claratif |  |

---

### Web assembly ü§ñ

- Compilation du code dans un language agnostique
- Se d√©barrasser d‚Äôun maximum de composants: Plus d‚Äôinterpr√©teur.
- peut tourner en back ou en front

https://webassembly.org/
https://developer.mozilla.org/fr/docs/WebAssembly

## Comparaison üÜö

![](assets/system-7.svg)

## R√©sum√© üß†

---

![](assets/system-0.svg)

---

![](assets/system-6.svg)

## Conclusion

![Untitled](assets/Untitled%206.png)
---

![](assets/system-11.svg)

---
- Co√ªt alternance perf, s√©curit√©:
    - On fait de la performance en faisant des design permissifs et ouvert
    - Puis on regrette
    - ~~Puis on rappel son ex~~
    - Puis on ajoute une couche de s√©curit√© au dessus
    - Puis on smash nos erreurs et on fait un nouveau standard
    - Puis, MARKETING üèÅ
    - Et on boucle
